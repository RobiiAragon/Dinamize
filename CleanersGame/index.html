<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phaser Game</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #gameContainer {
            width: 100%;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'gameContainer',
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            }
        };

        const game = new Phaser.Game(config);
        let player;
        let npcs = [];
        let cursors;
        let pauseKey;
        let isPaused = false;
        let pauseText;
        let mallObjects = [];
        let trashGroup;
        let score = 0;
        let scoreText;
        let trashTimers = [];
        let lastTrashCount = 0;
        let inventory = 0;
        let inventoryText;
        let inventoryFullText;
        let inventoryCleanText;
        let trashBin;
        let timerText;
        let gameOverText;
        let timeLimit = 120; // 2 minutes in seconds

        function preload() {
            this.load.image('trashBin', 'assets/Basurero.png');
            this.load.image('bench', 'assets/bench.png');
            this.load.image('kiosk', 'assets/kiosk.png');
            this.load.image('plant', 'assets/plant.png');
            this.load.image('trashTexture', 'assets/trash/trash.png');
            //player Left
            this.load.image('playerLeft', 'assets/player/idle/Adam_idle_left.png');
            this.load.image('playerRight', 'assets/player/idle/Adam_idle_rigth.png');
            this.load.image('playerUp', 'assets/player/idle/Adam_idle_up.png');
            this.load.image('playerDown', 'assets/player/idle/Adam_idle_down.png');
        }

        function create() {
            // Create player texture
            const graphics = this.add.graphics();
            graphics.fillStyle(0x0000ff, 1.0);
            graphics.fillRect(0, 0, 50, 50);
            graphics.generateTexture('playerTexture', 50, 50);
            graphics.clear();

            // Create NPC texture
            graphics.fillStyle(0xffff00, 1.0);
            graphics.fillRect(0, 0, 50, 50);
            graphics.generateTexture('npcTexture', 50, 50);
            graphics.clear();

            // Create trash texture
            graphics.fillStyle(0x808080, 1.0);
            graphics.fillRect(0, 0, 20, 20);
            graphics.generateTexture('trashTexture', 20, 20);
            graphics.destroy(); // Eliminar el gráfico después de generar las texturas

            // Create player
            player = this.physics.add.sprite(400, 300, 'playerDown');
            player.setCollideWorldBounds(true);
            player.setDisplaySize(40, 50); // Ajustar el tamaño del sprite del jugador


            // Create NPCs
            for (let i = 0; i < 6; i++) {
                const npc = this.physics.add.sprite(Phaser.Math.Between(100, 700), Phaser.Math.Between(100, 500), 'npcTexture');
                npc.setCollideWorldBounds(true);
                npcs.push(npc);

                // Set individual trash drop timer for each NPC
                const timer = this.time.addEvent({
                    delay: Phaser.Math.Between(5000, 9000), // Drop trash every x time
                    callback: () => dropTrash(npc),
                    callbackScope: this,
                    loop: true
                });
                trashTimers.push(timer);
            }
            
            // Create trash bin
            trashBin = this.physics.add.sprite(50, 50, 'trashBin');
                trashBin.setDisplaySize(120, 90); // Ajustar el tamaño del sprite
                trashBin.setCircle(220);
                trashBin.setImmovable(true);
                this.physics.add.collider(player, trashBin, emptyInventory, null, this);
                npcs.forEach(npc => this.physics.add.collider(npc, trashBin));

                // Create mall objects
                createMallObject(this, 200, 150, 'bench', 100, 50); // Bench
                createMallObject(this, 400, 150, 'plant', 50, 70); // plant
                createMallObject(this, 600, 150, 'bench', 100, 50); // Kiosk
                createMallObject(this, 200, 400, 'plant', 50, 70); // Plant
                createMallObject(this, 400, 400, 'kiosk', 100, 50); // Kiosk
                createMallObject(this, 600, 400, 'plant', 50, 70); // Plant

            // Create world bounds
            this.physics.world.setBounds(0, 0, 800, 600);

            // Colliders between player and NPCs
            npcs.forEach(npc => this.physics.add.collider(player, npc));
            npcs.forEach((npc1, index) => {
                for (let j = index + 1; j < npcs.length; j++) {
                    this.physics.add.collider(npc1, npcs[j]);
                }
            });

            // Colliders between NPCs and mall objects
            mallObjects.forEach(obj => {
                npcs.forEach(npc => this.physics.add.collider(npc, obj));
                this.physics.add.collider(player, obj);
            });

            // Create trash group
            trashGroup = this.physics.add.group();
            this.physics.add.overlap(player, trashGroup, collectTrash, null, this);

            // Input
            cursors = this.input.keyboard.createCursorKeys();
            pauseKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);

            // Pause text
            pauseText = this.add.text(400, 300, 'PAUSA', { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
            pauseText.setVisible(false);

            // Score text
            scoreText = this.add.text(16, 16, 'Puntos: ' + score, { fontSize: '32px', fill: '#fff' });

            // Inventory text
            inventoryText = this.add.text(16, 50, 'Inventario: ' + inventory, { fontSize: '32px', fill: '#fff' });

            // Inventory full text
            inventoryFullText = this.add.text(400, 300, 'Inventario lleno, ve a vaciarlo', { fontSize: '32px', fill: '#ff0000' }).setOrigin(0.5);
            inventoryFullText.setVisible(false);

            // Inventory clean text
            inventoryCleanText = this.add.text(400, 300, 'Inventario limpio', { fontSize: '32px', fill: '#00ff00' }).setOrigin(0.5);
            inventoryCleanText.setVisible(false);

            // Timer text
            timerText = this.add.text(16, 84, 'Tiempo: 02:00', { fontSize: '32px', fill: '#fff' });

            // Game over text
            gameOverText = this.add.text(400, 300, '', { fontSize: '32px', fill: '#fff' }).setOrigin(0.5);
            gameOverText.setVisible(false);

            // Set NPC movement timer
            this.time.addEvent({
                delay: 1000, // Change direction every second
                callback: changeNpcDirection,
                callbackScope: this,
                loop: true
            });

            // Set trash penalty timer
            this.time.addEvent({
                delay: 1000, // Check trash count every second
                callback: checkTrashPenalty,
                callbackScope: this,
                loop: true
            });

            // Set game timer
            this.time.addEvent({
                delay: 1000, // Update timer every second
                callback: updateTimer,
                callbackScope: this,
                loop: true
            });
        }

        function createMallObject(scene, x, y, key, width, height) {
            const obj = scene.physics.add.sprite(x, y, key);
            obj.setDisplaySize(width, height); // Ajustar el tamaño del sprite
            obj.setImmovable(true);
            mallObjects.push(obj);
        }

        function update() {
            if (Phaser.Input.Keyboard.JustDown(pauseKey) && !gameOverText.visible) {
                isPaused = !isPaused;
                if (isPaused) {
                    this.physics.pause();
                    pauseText.setVisible(true);
                    trashTimers.forEach(timer => timer.paused = true);
                    this.time.paused = true; // Pausar el tiempo
                } else {
                    this.physics.resume();
                    pauseText.setVisible(false);
                    trashTimers.forEach(timer => timer.paused = false);
                    this.time.paused = false; // Reanudar el tiempo
                }
            }

            if (!isPaused) {
                player.setVelocity(0);

                if (cursors.left.isDown) {
                    player.setVelocityX(-200);
                    player.setTexture('playerLeft');
                } else if (cursors.right.isDown) {
                    player.setVelocityX(200);
                    player.setTexture('playerRight');
                }

                if (cursors.up.isDown) {
                    player.setVelocityY(-200);
                    player.setTexture('playerUp');
                } else if (cursors.down.isDown) {
                    player.setVelocityY(200);
                    player.setTexture('playerDown');
                }

                // Apply separation behavior to NPCs
                applySeparation();
            }
        }

        function changeNpcDirection() {
            npcs.forEach(npc => {
                const angle = Phaser.Math.FloatBetween(0, 2 * Math.PI);
                const speed = 100;
                npc.setVelocity(Math.cos(angle) * speed, Math.sin(angle) * speed);
            });
        }

        function applySeparation() {
            const separationDistance = 50;
            npcs.forEach(npc1 => {
                let separationForceX = 0;
                let separationForceY = 0;
                npcs.forEach(npc2 => {
                    if (npc1 !== npc2) {
                        const distance = Phaser.Math.Distance.Between(npc1.x, npc1.y, npc2.x, npc2.y);
                        if (distance < separationDistance) {
                            const angle = Phaser.Math.Angle.Between(npc1.x, npc1.y, npc2.x, npc2.y);
                            separationForceX -= Math.cos(angle);
                            separationForceY -= Math.sin(angle);
                        }
                    }
                });
                npc1.setVelocity(npc1.body.velocity.x + separationForceX * 10, npc1.body.velocity.y + separationForceY * 10);
            });
        }

        function dropTrash(npc) {
            if (trashGroup.countActive(true) < 20) {
                const trash = trashGroup.create(npc.x, npc.y, 'trashTexture');
                trash.setCollideWorldBounds(true);
                trash.setDisplaySize(20, 30); // Ajusta el tamaño de la basura aquí
            }
        }

        function collectTrash(player, trash) {
            if (inventory < 7) {
                trash.destroy();
                inventory++;
                score += 10;
                scoreText.setText('Puntos: ' + score);
                inventoryText.setText('Inventario: ' + inventory);
            } else {
                inventoryFullText.setVisible(true);
                this.time.delayedCall(2000, () => {
                    inventoryFullText.setVisible(false);
                });
            }
        }

        function emptyInventory() {
            if (inventory > 0) {
                inventory = 0;
                inventoryText.setText('Inventario: ' + inventory);
                inventoryCleanText.setVisible(true);
                this.time.delayedCall(2000, () => {
                    inventoryCleanText.setVisible(false);
                });
            }
        }

        function checkTrashPenalty() {
        const trashCount = trashGroup.countActive(true);
        if (trashCount > 10 && trashCount < 20 && trashCount > lastTrashCount) {
            score = Math.max(0, score - 10); // Asegurarse de que el puntaje no sea menor a 0
            scoreText.setText('Puntos: ' + score);
        }
        lastTrashCount = trashCount;
    }

        function updateTimer() {
            if (timeLimit > 0) {
                timeLimit--;
                const minutes = Math.floor(timeLimit / 60);
                const seconds = timeLimit % 60;
                timerText.setText('Tiempo: ' + minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0'));
            } else {
                endGame.call(this);
            }
        }

        function endGame() {
            this.physics.pause();
            trashTimers.forEach(timer => timer.paused = true);
            gameOverText.setText('Juego terminado! Puntaje final: ' + score);
            gameOverText.setVisible(true);
            isPaused = true; // Asegurarse de que el juego esté pausado
        }
    </script>
</body>
</html>